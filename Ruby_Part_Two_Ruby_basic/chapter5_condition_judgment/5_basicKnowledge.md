# 第五章：条件判断
详细讨论一下作为控制结构之一的条件判断，主要包括以下内容。
- 什么是条件判断
- 条件判断中不可或缺的比较运算符、真假值（布尔值）、逻辑运算符
- 条件判断的种类及其写法和使用方法

## 5.1 什么是条件判断
> 我们来考虑一下如何将公历转换为平成纪年（日本的纪年方法。1989 年为平成元年，2017 年是平成 29 年）。
首先，我们将输入的字符串转换为数值，然后减去 1988，最后输出运算结果，结束程序，如[ad2pingcheng](./ad2pingcheng.rb)里代码所示
执行结果如下：
```
> ruby ad2pingcheng.rb 2016
28
```
但是，这个程序有点小问题。如果我们输入 1988 年以前的年份，返回值会变成 0 或者负数。比如：
```
> ruby ad2pingcheng.rb 1980
-8
```
按道理，1989 年以前的年份是不能转换为平成 ×× 年的，因此程序本不应允许输入示例中那样的年份。

我们将程序稍微改进一下，若输入 1989 年以前的年份，程序则返回“无法转换”的提示。

在这样的情况下，为了实现程序在“某个条件时执行○○处理，否则执行 ×× 处理”，Ruby 为我们准备了条件判断语句。

条件判断语句主要有以下三种。
- if 语句
- unless 语句
- case 语句

## 5.2 Ruby中的条件

### 条件与真假值（布尔值）
#### 条件
我们在之前的章节已经介绍过在**条件判断**中常用到的比较运算符。等号 = =，不等号 >、< 等都是比较运算符。

比较的结果分为 true 和 false 两种。顾名思义，比较结果正确时为 true，错误时为 false。

除了比较运算符外，Ruby 中还有很多可以作为条件判断的方法。例如，字符串类的 empty? 方法，在该字符串的长度为 0 时返回 true，否则返回 false。
```
p "".empty?         #=> true
p "AAA".empty?      #=> false
```
另外，除了 true 和 false 外，还有其他值可作为条件判断的值。例如，用正则表达式进行匹配时，匹配成功返回该字符串的位置，匹配失败返回 nil。
```
p /Ruby/ =~ "Ruby"      #=> 0
p /Ruby/ =~ "Diamond"   #=> nil
```
#### 真假值（布尔值）
真|false、nil以外的所有对象|
:-|:-
假|false、nil|

也就是说，Ruby 会认为 false 与 nil 代表假，除此以外的所有值都代表真。

因此，Ruby 中的真 / 假并非绝对等同于 true/false。同时，不返回 true 或 false 的方法只要能返回 nil，也可作为条件判断的表达式来使用。

在 Ruby 中还有个约定俗成的规则，为了使程序更容易理解，**返回真假值的方法都要以 ? 结尾**。建议大家在写程序时也遵守这个规则。

## 5.3 逻辑运算符
> 在判断多个条件表达式时，我们会用到逻辑运算符 && 和 ||。
- 条件1 && 条件2
    表示条件 1 为真，并且条件 2 也为真时，则整体的表达式返回真。两者中只要有一个为假， 则整体的表达式返回假。
- 条件 1 | | 条件 2
    表示条件 1 为真，或者条件 2 为真时，整体的表达式返回真。两者同时为假时，则整体的 表达式返回假。
- ! 条件
    表示相反的条件。也就是说，条件为假时，表达式返回真;条件为真时，表达式返回假。

我们想判断整数 x 是否在 1 到 10 之间，if 语句可以这么写。
```
if x >= 1 && x <= 10
    '
    '
end
```
与上面的条件相反，表示“1到10以外”时使用!，表达式可以写成!(x >= 1 && x <= 10)。

不过，像下面这样写成“小于 1，或者大于 10”可能更加直接，更便于理解。
```
if x < 1 || x > 10
    '
    '
end
```
条件判断对于控制程序的行为非常重要。过于复杂、难以理解的条件，会使程序的目的也会变得难以琢磨。建议大家在写程序时，尽量写便于理解的条件。

在 Ruby 中，还有与 &&、||、! 意思相同，但优先级略低的逻辑运算符 and、or、not。

## 5.4 if 语句
> if 语句是最基本的条件判断语句
用法如下
```
if 条件 then
    处理
end
```
※ 可以省略 then。 

在这基础上可再加上 elsif、else。
```
if 条件1 then
    处理 1
elsif 条件2 then
    处理 2
elsif 条件3 then
    处理 3
else
    处理 4
end
```
※ 可以省略 then。

我们来看看使用 elsif 的例子:[if_elsif.rb](./if_elsif.rb)

## 5.5 unless语句
> unless 语句的用法刚好与 if 语句相反
如下所示
```
unless 条件 then 
    处理
end
```
※ 可以省略 then。

unless 语句的形式和 if 语句一样。但 if 语句是条件为真时执行处理，unless 语句则刚好相反，条件为假时执行处理。

这是使用 unless 的例子：[unless.rb](./unless.rb)

unless 语句也可以使用 else:
```
unless 条件
    处理 1
else 
    处理 2
end
```
这个与下面的 if 语句是等价的。(注意处理的序号！！！！！！！)
```
if 条件 
    处理 2
else 
    处理 1
end
```
对比以上两种写法，我们可以知道处理 1 和处理 2 的位置互换了，if 语句通过这样的互换， 能达到与使用 unless 语句时同样的效果。

## 5.6 case 语句
> 条件有多个时，使用 if 与 elsif 的组合虽然也能达到判断多个条件的效果，但是如果需要比较的对象只有一个，根据这个对象值的不同，执行不同的处理时，使用 case 语句会使程序更简单，更便于理解。
case 语句的用法如下所示
```
case 比较对象 
when 值1 then
    处理 1
when 值2 then
    处理 2
when 值3 then
    处理 3 
else 
    处理 4
end
```

- 还有，when 可以一次指定多个值。如代码[case.rb](./case.rb)所示,从数组 tags 的开头依次取出元素，判断元素值，输出相应的结果。
- 我们再来看看其他例子：[case_class.rb](./case_class.rb):
    在本例中，程序判断传过来的对象类型是字符串(String 类)还是数值(Numeric 类)， 或者以上两者均不是，然后再输出相应的结果。
    在这里，我们同样是使用 case 语句，不过判断的主体与之前的例子有点区别。
    本例中 的 when 实际上并不是直接判断传过来的字符串，而是先查找该对象属于哪个类，然后再根据这个类的信息来进行条件判断。
- 我们还可以根据正则表达式的匹配结果进行不同处理。下面是使用正则表达式进行判断 的 case 语句的例子。
    ```
    text.each_line do |line|
        case line
        when /^From:/i
            puts "发现寄信人信息" 
        when /^To:/i
            puts "发现收信人信息" 
        when /^Subject:/i
            puts "发现主题信息" 
        when /^$/
            puts "头部解析完毕"
            exit
        else
            ## 跳出处理
        end
    end
    ```
    这是一个解析电子邮件头部的程序。为了简化程序，我们并没有考虑有多个头部的情况，而且电子邮件里的内容我们也没取出来。在这里，大家掌握程序的大致处理流程就可以了。

    each_line 方法会逐行读取电子邮件正文的文本数据 text，并将每行的内容赋值给变量 line。这个是处理文件、文本数据时的典型写法。

    接着 case 语句根据得到的字符串的内容执行不同的处理。以 From: 开头时输出“发现寄信人信息”，以 To: 开头时输出“发现收信人信息”，以 Subject: 开头时输出“发现主题信息”。

    最后的 when 判断的 /^$/，表示行的开头后马上就接着是行尾的意思(在正则表达式中，^ 表示匹配字符串的开始，$ 表示匹配字符串的结束。)，也就是说，这是表示空行的正则表达式。

    电子邮件的头部和正文间一定会以空行作为间隔，因此根据这个规则我们就可以把空行作为头部结束的标志。when 遇到空行，输出“头部解析完毕”的信息，然后调用 exit 方法，结束程序。

### === 与 case语句
case 语句在判断与 when 指定的值是否相等时，实际上是使用 === 运算符来判断的。

左边是数值或者字符串时，=== 与 == 的意义是一样的，除此以外，=== 还可以与 =~ 一样来**判断正则表达式是否匹配**，或者判断**右边的对象是否属于左边的类**，等等。

相比单纯地判断两边的值是否相等，=== 能表达更加广义的“相等”。
```
p (/zz/ === "xyzzy")        #=> true
p (String === "xyzzy")      #=> true
p ((1..3) === 2)            #=> true
```
用 if 语句改写 case 语句的程序如下所示。请注意**when 指定的对象在 === 的左边。**
```
case value
when A
    处理1
when B
    处理 2 
else
    处理 3 
end
```
  |
```
if A === value 
    处理1
elsif B === value 
    处理2
else 
    处理 3
end
```
## 5.7 if修饰符与unless修饰符
> if 与 unless 可以像下面这样写在希望执行的代码的后面。
```
puts "a比b大" if a > b
```
虽然这与下面的写法是等价的，但使用修饰符的写法会使程序更加紧凑，程序逻辑更加突出。另外，在使用修饰符的写法时，要注意程序的易读性。
```
if a > b
    puts "a比b大"
end
```

## 5.8 小结
- 真假值（布尔值）
    真假值是条件表达式的返回值。
    + nil 或者 false 时为假
    + 除此以外的值为真
- 条件判断语句
    条件判断语句有以下 3 种。
    + if 语句
    + unless 语句
    + case 语句
- 比较
    用 if 语句、unless 语句进行比较时，会用到比较运算符(==、!=、<、> 等)、以 ? 结尾的方法、逻辑运算符等。
- if 语句、unless 语句
    两者皆为条件判断的基本语句。
- case语句
    在需要根据对象的不同状态采取不同的处理时，我们会用到 case 语句。
    
    分情况处理时，不同的对象所采取的判断方法也不一样。具体来说，就是根据 === 运算符 的比较特性，实现分情况处理。

## 专栏
### 对象的同一性
> 所有的对象都有标识和值。
**标识(ID)**用来表示对象的同一性。Ruby 中所有对象都是唯一的，对象的 ID 可以通过 object_id(或者` __id__`)方法获得。
```
ary1 = []
ary2 = []
p ary1.object_id    #=> 67653636
p ary2.object_id    #=> 67650432
```
我们**用 equal? 方法**判断两个对象是否为同一个对象(ID 是否相同)。
```
str1 = "foo"
str2 = str1
str3 = "f" + "o" + "o"
p str1.equal?(str2)     #=> true
p str1.equal?(str3)     #=> false
```
对象的**值**就是对象拥有的信息。例如，只要对象的字符串内容相等，Ruby 就会认为对象的值相等。Ruby 使**用 == 来**判断对象的值是否相等。
```
str1 = "foo"
str2 = "f" + "o" + "o"
p str1 == str2          #=> true
```
除了 == 以外，Ruby 还提供**了 eql? 方法**来判断对象的**值是否相等**。== 与 eql? 都是 Object 类定义的方法，大部分情况下它们的执行结果都是一样的。

但也有例外，数值类会重定义 eql? 方法，因此执行后有不一样的结果。
```
p 1.0 == 1          #=> true 
p 1.0.eql?(1)       #=> false
```
凭直觉来讲，把 1.0 与 1 判断为相同的值会更加方便。

一般情况下进行值的比较时会使用 ==，但是在一些需要进行更严谨的比较的程序中，就需要用到 eql? 方法。

例如，0 与 0.0 作为散列的键时会被判断为不同的键，这是由于散列对象内部的键的比较使用了 eql? 方法。
```
hash = { 0 => "0"}
p hash[0.0]  #=> nil
p hash[0]    #=> "0"
```
